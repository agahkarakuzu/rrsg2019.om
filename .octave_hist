_make_figures("/tmp/tmpu1_yycv3", "png", "Figure", -1, -1, 0, 0)
% This cell will be run automatically based upon your selection from the blue toggle above. 
% Perform NUFFT to interpolate data onto cartesian grid. 
im = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);
% Transform sensitivity maps to cartesian k-space using FFT
% -u denotes unitary transform
% 7 sets the bitmask level
im_ks = bart('fft -u 7', im);
% For details regarding BART's ECALIB, please see the implementation notes section.
if S_select == 1
    disp('Calculating S using ECALIB.');
    calib = bart('ecalib -r 20 -m1 -I',im_ks);
    disp('--> Done...')
elseif S_select == 2
    disp('Calculating S using CALDIR.');
    calib = bart('caldir 20',im_ks);
    disp('--> Done...'); 
end
_make_figures("/tmp/tmpnkvxt_o1", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpydq8tyw9", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmptappn7ew", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(calib))
_make_figures("/tmp/tmp1iwp6z3m", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp741j9x8h", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(calib))
_make_figures("/tmp/tmpvb5m1q25", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu Sep 19 14:45:38 2019 UTC <jovyan@41bebeae62a1>
PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
graphics_toolkit
more off; source ~/.octaverc; cd("/home/jovyan");PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
addpath("/srv/conda/envs/notebook/lib/python3.7/site-packages/octave_kernel")
graphics_toolkit('gnuplot')
set(0, 'defaultfigurevisible', 'off');
version
path(path, '/srv/conda/envs/notebook/lib/python3.7/site-packages/sos_matlab')
pkg load dataframe
_make_figures("/tmp/tmp3gj2gskr", "png", "Figure", -1, -1, 0, 0)
disp('Executed automatically');
disp('Cell to load octave packages. To show, select the cell and click arrow up icon in the toolbar.');
pkg load image 
pkg load optim
_make_figures("/tmp/tmpw_2l3_9k", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpt_dx8n1z", "png", "Figure", -1, -1, 0, 0)
% Mex c files for gridding by Brian Hargreaves and Philip Beatty 
% http://mrsrl.stanford.edu/~brian/gridding/
disp('Executed automatically');
disp('Cell to MEX c functions for dcf. To show, select the cell and click arrow up icon in the toolbar.');
mex gridlut_mex.c
mex calcdcflut_mex.c
_make_figures("/tmp/tmpruydkb7c", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpfgex60cc", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmp6y_xnvn9", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp1duinhxt", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmp4xxipsof", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpo7zxwdc6", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
    tmp = S.*inp; % Multiply the intensity corrected image with coil sensitivities. This will produce one image per channel stored in tmp variable
    E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space (see implementation notes for details)
end
_make_figures("/tmp/tmpyflqn6l1", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpfsew7yyk", "png", "Figure", -1, -1, 0, 0)
function EH = opEH(inp,S,traj)
  
  tmp = squeeze((1+1i)*ones(size(S)));
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp); % Adjoint NUFFT to image domain (see implementation notes)
  
  Sstar = conj(S(:,:,1,:)); %  Complex conjugate of sensitivity profiles (see Fig. 1)
  
  EH = bart('rss 8 ',tmp.*Sstar); % Images scaled by complex conjugate of sensitivity profiles and SOS combined
  
end
_make_figures("/tmp/tmpo6y23532", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp6s7mwk2e", "png", "Figure", -1, -1, 0, 0)
function out = opF(im,beta,r)
    
    ks = 1/sqrt(numel(im))*fftshift(fftn(ifftshift(im)));
    
    dim = size(ks);
    center = (dim + 1)/2;
    [x,y] = meshgrid(-(center(2)-1):(dim(2)-center(2)),-(center(1)-1):(dim(1)-center(1)));
    kRadius = sqrt(x.^2 + y.^2);
    f_k = 0.5 + 1/pi.*atan(beta.*((r-kRadius)/r)); 
    out = sqrt(numel(ks.*f_k))*fftshift(ifftn(ifftshift(ks.*f_k)));
end
_make_figures("/tmp/tmp3y78gff7", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpg6wt0lsg", "png", "Figure", -1, -1, 0, 0)
function [b,deltas] = cg_solve(a,I,S,dcf,maxstep,trajectory)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    end
    
end
_make_figures("/tmp/tmphnap0puc", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpb991y0n8", "png", "Figure", -1, -1, 0, 0)
function [im,deltas] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
    [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory);
    im = opF(im.*I,100,60);
end
_make_figures("/tmp/tmp1lv2wzj4", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp2_8zfcwa", "png", "Figure", -1, -1, 0, 0)
<div class="alert alert-info">
  <strong><span class="badge">4.1.1</span></strong> <b>Reference reconstruction</b>
</div>
_make_figures("/tmp/tmp7zso4b1g", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp1xz4naf0", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmphhs1graz", "png", "Figure", -1, -1, 0, 0)
S_select = 1
_make_figures("/tmp/tmprcsv5z6h", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpefwuujaz", "png", "Figure", -1, -1, 0, 0)
% This cell will be run automatically based upon your selection from the blue toggle above. 
% Perform NUFFT to interpolate data onto cartesian grid. 
im = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);
% Transform sensitivity maps to cartesian k-space using FFT
% -u denotes unitary transform
% 7 sets the bitmask level
im_ks = bart('fft -u 7', im);
% For details regarding BART's ECALIB, please see the implementation notes section.
if S_select == 1
    disp('Calculating S using ECALIB.');
    calib = bart('ecalib -r 20 -m1 -I',im_ks);
    disp('--> Done...')
elseif S_select == 2
    disp('Calculating S using CALDIR.');
    calib = bart('caldir 20',im_ks);
    disp('--> Done...'); 
end
_make_figures("/tmp/tmpgl8jy9oz", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp48cedqg5", "png", "Figure", -1, -1, 0, 0)
% Please see HelperFunctions folder for subSample.m 
[outRD_x2, outTR_x2] = subSample(rawdata,trajectory,2,nSpokes);
[outRD_x3, outTR_x3] = subSample(rawdata,trajectory,3,nSpokes);
[outRD_x4, outTR_x4] = subSample(rawdata,trajectory,4,nSpokes);
_make_figures("/tmp/tmpt55gv2yo", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpnhdlvrz5", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpsxshhhqc", "png", "Figure", -1, -1, 0, 0)
dcf_select = 1
_make_figures("/tmp/tmp5g1z50y6", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpnjafrf9d", "png", "Figure", -1, -1, 0, 0)
% dcf_select variable is determined by the blue toggle buttons above.
% This cell will be run automatically upon your selection. 
if dcf_select == 1
   
    disp('Simple DCF estimation')
    dcf = abs(trajectory(1,:,:) + 1i*trajectory(2,:,:));
    dcf = dcf/max(dcf(:));
   disp('--> Done..');
   
elseif dcf_select==2
   
    disp('Calculating DCF using code written in C...')
    dcf = calcdcflut(trajectory,300); 
    dcf = reshape(dcf,[3 nFE nSpokes]);
    disp('--> Done..');
    
end
_make_figures("/tmp/tmpcvvn3g7t", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpypjka9h6", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
    tmp = S.*inp; % Multiply the intensity corrected image with coil sensitivities. This will produce one image per channel stored in tmp variable
    E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space (see implementation notes for details)
end
_make_figures("/tmp/tmpidxns0wg", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpekfaoszv", "png", "Figure", -1, -1, 0, 0)
function EH = opEH(inp,S,traj)
  
  tmp = squeeze((1+1i)*ones(size(S)));
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp); % Adjoint NUFFT to image domain (see implementation notes)
  
  Sstar = conj(S(:,:,1,:)); %  Complex conjugate of sensitivity profiles (see Fig. 1)
  
  EH = bart('rss 8 ',tmp.*Sstar); % Images scaled by complex conjugate of sensitivity profiles and SOS combined
  
end
_make_figures("/tmp/tmp647mbag2", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp9uf0b0as", "png", "Figure", -1, -1, 0, 0)
function out = opF(im,beta,r)
    
    ks = 1/sqrt(numel(im))*fftshift(fftn(ifftshift(im)));
    
    dim = size(ks);
    center = (dim + 1)/2;
    [x,y] = meshgrid(-(center(2)-1):(dim(2)-center(2)),-(center(1)-1):(dim(1)-center(1)));
    kRadius = sqrt(x.^2 + y.^2);
    f_k = 0.5 + 1/pi.*atan(beta.*((r-kRadius)/r)); 
    out = sqrt(numel(ks.*f_k))*fftshift(ifftn(ifftshift(ks.*f_k)));
end
_make_figures("/tmp/tmp4yx_z3mm", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmppm53o0l5", "png", "Figure", -1, -1, 0, 0)
function [b,deltas] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
end
_make_figures("/tmp/tmp2q734p90", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp7bqh9oxg", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
    [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    im = opF(im.*I,100,60);
end
_make_figures("/tmp/tmp7uty9svz", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpxvxl29t6", "png", "Figure", -1, -1, 0, 0)
[im_ref,deltas_ref] = main_sense(rawdata, calib, trajectory,I,dcf,150,0.01);
_make_figures("/tmp/tmpns43f4o3", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu Sep 19 16:03:17 2019 UTC <jovyan@41bebeae62a1>
PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
graphics_toolkit
more off; source ~/.octaverc; cd("/home/jovyan");PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
addpath("/srv/conda/envs/notebook/lib/python3.7/site-packages/octave_kernel")
graphics_toolkit('gnuplot')
set(0, 'defaultfigurevisible', 'off');
version
path(path, '/srv/conda/envs/notebook/lib/python3.7/site-packages/sos_matlab')
pkg load dataframe
_make_figures("/tmp/tmpmtfrvms4", "png", "Figure", -1, -1, 0, 0)
disp('Executed automatically');
disp('Cell to load octave packages. To show, select the cell and click arrow up icon in the toolbar.');
pkg load image 
pkg load optim
_make_figures("/tmp/tmpgfhnh34j", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmps4m9rcs_", "png", "Figure", -1, -1, 0, 0)
% Mex c files for gridding by Brian Hargreaves and Philip Beatty 
% http://mrsrl.stanford.edu/~brian/gridding/
disp('Executed automatically');
disp('Cell to MEX c functions for dcf. To show, select the cell and click arrow up icon in the toolbar.');
mex gridlut_mex.c
mex calcdcflut_mex.c
_make_figures("/tmp/tmpf06lwu3m", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp4t31rs53", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmpfj45p_jn", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp2h7_1b_y", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmp81sw38cb", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpua0f7f30", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
    tmp = S.*inp; % Multiply the intensity corrected image with coil sensitivities. This will produce one image per channel stored in tmp variable
    E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space (see implementation notes for details)
end
_make_figures("/tmp/tmp4n1ffqrq", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp_rko2x6g", "png", "Figure", -1, -1, 0, 0)
function EH = opEH(inp,S,traj)
  
  tmp = squeeze((1+1i)*ones(size(S)));
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp); % Adjoint NUFFT to image domain (see implementation notes)
  
  Sstar = conj(S(:,:,1,:)); %  Complex conjugate of sensitivity profiles (see Fig. 1)
  
  EH = bart('rss 8 ',tmp.*Sstar); % Images scaled by complex conjugate of sensitivity profiles and SOS combined
  
end
_make_figures("/tmp/tmpae90_jot", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp4x6kuff5", "png", "Figure", -1, -1, 0, 0)
function out = opF(im,beta,r)
    
    ks = 1/sqrt(numel(im))*fftshift(fftn(ifftshift(im)));
    
    dim = size(ks);
    center = (dim + 1)/2;
    [x,y] = meshgrid(-(center(2)-1):(dim(2)-center(2)),-(center(1)-1):(dim(1)-center(1)));
    kRadius = sqrt(x.^2 + y.^2);
    f_k = 0.5 + 1/pi.*atan(beta.*((r-kRadius)/r)); 
    out = sqrt(numel(ks.*f_k))*fftshift(ifftn(ifftshift(ks.*f_k)));
end
_make_figures("/tmp/tmpw66pat7p", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp9eel_ey6", "png", "Figure", -1, -1, 0, 0)
function [b,deltas] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
end
_make_figures("/tmp/tmp5dslflrs", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpuxcb8vd3", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
    [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    im = opF(im.*I,100,60);
end
_make_figures("/tmp/tmpxihn9vqt", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpb5e0kwp7", "png", "Figure", -1, -1, 0, 0)
[im_ref,deltas_ref] = main_sense(rawdata, calib, trajectory,I,dcf,150,10^(-12));
_make_figures("/tmp/tmpo34n8gyx", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmps0ueh_62", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmp5pso520t", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpfxfj1qq2", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmpjdy2w29y", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmptwgzwyd7", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp3natrvaq", "png", "Figure", -1, -1, 0, 0)
S_select = 1
_make_figures("/tmp/tmpx292ta4h", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpd5gq5pcz", "png", "Figure", -1, -1, 0, 0)
% This cell will be run automatically based upon your selection from the blue toggle above. 
% Perform NUFFT to interpolate data onto cartesian grid. 
im = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);
% Transform sensitivity maps to cartesian k-space using FFT
% -u denotes unitary transform
% 7 sets the bitmask level
im_ks = bart('fft -u 7', im);
% For details regarding BART's ECALIB, please see the implementation notes section.
if S_select == 1
    disp('Calculating S using ECALIB.');
    calib = bart('ecalib -r 20 -m1 -I',im_ks);
    disp('--> Done...')
elseif S_select == 2
    disp('Calculating S using CALDIR.');
    calib = bart('caldir 20',im_ks);
    disp('--> Done...'); 
end
_make_figures("/tmp/tmp1i2t4xbu", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp58bnsebn", "png", "Figure", -1, -1, 0, 0)
% Please see HelperFunctions folder for subSample.m 
[outRD_x2, outTR_x2] = subSample(rawdata,trajectory,2,nSpokes);
[outRD_x3, outTR_x3] = subSample(rawdata,trajectory,3,nSpokes);
[outRD_x4, outTR_x4] = subSample(rawdata,trajectory,4,nSpokes);
_make_figures("/tmp/tmpu9ynx9l8", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpss_rnhtk", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpx6nryosl", "png", "Figure", -1, -1, 0, 0)
dcf_select = 1
_make_figures("/tmp/tmpg9xxkwok", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpjcorl_rf", "png", "Figure", -1, -1, 0, 0)
% dcf_select variable is determined by the blue toggle buttons above.
% This cell will be run automatically upon your selection. 
if dcf_select == 1
   
    disp('Simple DCF estimation')
    dcf = abs(trajectory(1,:,:) + 1i*trajectory(2,:,:));
    dcf = dcf/max(dcf(:));
   disp('--> Done..');
   
elseif dcf_select==2
   
    disp('Calculating DCF using code written in C...')
    dcf = calcdcflut(trajectory,300); 
    dcf = reshape(dcf,[3 nFE nSpokes]);
    disp('--> Done..');
    
end
_make_figures("/tmp/tmp85dd_596", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpyhf35t0f", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
    tmp = S.*inp; % Multiply the intensity corrected image with coil sensitivities. This will produce one image per channel stored in tmp variable
    E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space (see implementation notes for details)
end
_make_figures("/tmp/tmpe14rky03", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpc2redrco", "png", "Figure", -1, -1, 0, 0)
function EH = opEH(inp,S,traj)
  
  tmp = squeeze((1+1i)*ones(size(S)));
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp); % Adjoint NUFFT to image domain (see implementation notes)
  
  Sstar = conj(S(:,:,1,:)); %  Complex conjugate of sensitivity profiles (see Fig. 1)
  
  EH = bart('rss 8 ',tmp.*Sstar); % Images scaled by complex conjugate of sensitivity profiles and SOS combined
  
end
_make_figures("/tmp/tmp0u6q310w", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpeg9fe2iu", "png", "Figure", -1, -1, 0, 0)
function out = opF(im,beta,r)
    
    ks = 1/sqrt(numel(im))*fftshift(fftn(ifftshift(im)));
    
    dim = size(ks);
    center = (dim + 1)/2;
    [x,y] = meshgrid(-(center(2)-1):(dim(2)-center(2)),-(center(1)-1):(dim(1)-center(1)));
    kRadius = sqrt(x.^2 + y.^2);
    f_k = 0.5 + 1/pi.*atan(beta.*((r-kRadius)/r)); 
    out = sqrt(numel(ks.*f_k))*fftshift(ifftn(ifftshift(ks.*f_k)));
end
_make_figures("/tmp/tmpj3ed8g9d", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpkdl9y72r", "png", "Figure", -1, -1, 0, 0)
function [b,deltas] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
end
_make_figures("/tmp/tmpkpc683zj", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpjsgx4e7r", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
    [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    im = opF(im.*I,100,60);
end
_make_figures("/tmp/tmp93x64a6_", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp27qmlwgw", "png", "Figure", -1, -1, 0, 0)
[im_ref,deltas_ref] = main_sense(rawdata, calib, trajectory,I,dcf,150,10^(-12));
_make_figures("/tmp/tmpu0e0h2xv", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpn0nk3i73", "png", "Figure", -1, -1, 0, 0)
save ref_recon.mat im_ref deltas_ref
_make_figures("/tmp/tmp7s6bbz85", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp8kpn0fxq", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
    
    if nargout ==3 && nargin ==7 
    % This means that ref image is passed. 
    
    refN = ref(:)'.*ref(:);
    ref_dif = I.*b - ref;
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))/refN);
    
    end 
    
end
_make_figures("/tmp/tmp211u95p6", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpjbm555e8", "png", "Figure", -1, -1, 0, 0)
%[im_ref,deltas_ref] = main_sense(rawdata, calib, trajectory,I,dcf,150,10^(-12));
_make_figures("/tmp/tmp3z4o9thy", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpmo66ac_g", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
    
    if nargout ==3 && nargin ==7 
    % This means that ref image is passed. 
    
    refN = ref(:)'.*ref(:);
    ref_dif = I.*b - ref;
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))/refN);
    
    end 
    
end
_make_figures("/tmp/tmp8qb3nptz", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpixaddjdd", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a,refdif] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol,ref)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
    
    
     if nargout ==4 && nargin ==8 
    % This means that ref image is passed. 
    
        [im,deltas,refdif] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol,ref);
    
    else
    
        [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    
    end 
    
    im = opF(im.*I,100,60);
    
    
end
_make_figures("/tmp/tmpbjqbqpuf", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpmuxjivc6", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2, calib, outTR_x2,I,dcf,10,0.01,im_ref)
_make_figures("/tmp/tmpyf4aeoly", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpp8n7v5lw", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),10,0.01,im_ref)
_make_figures("/tmp/tmppwatcbz_", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu Sep 19 16:41:08 2019 UTC <jovyan@41bebeae62a1>
PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
graphics_toolkit
more off; source ~/.octaverc; cd("/home/jovyan");PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
addpath("/srv/conda/envs/notebook/lib/python3.7/site-packages/octave_kernel")
graphics_toolkit('gnuplot')
set(0, 'defaultfigurevisible', 'off');
version
path(path, '/srv/conda/envs/notebook/lib/python3.7/site-packages/sos_matlab')
pkg load dataframe
_make_figures("/tmp/tmp008i7uxm", "png", "Figure", -1, -1, 0, 0)
disp('Executed automatically');
disp('Cell to load octave packages. To show, select the cell and click arrow up icon in the toolbar.');
pkg load image 
pkg load optim
_make_figures("/tmp/tmpml3n99l4", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp4q0bo6x3", "png", "Figure", -1, -1, 0, 0)
% Mex c files for gridding by Brian Hargreaves and Philip Beatty 
% http://mrsrl.stanford.edu/~brian/gridding/
disp('Executed automatically');
disp('Cell to MEX c functions for dcf. To show, select the cell and click arrow up icon in the toolbar.');
mex gridlut_mex.c
mex calcdcflut_mex.c
_make_figures("/tmp/tmpi2dlfxm0", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpuej7c3k6", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmp0aquubxg", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmppbhv3qom", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmp687mrb1p", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpg1c2hbwq", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
    tmp = S.*inp; % Multiply the intensity corrected image with coil sensitivities. This will produce one image per channel stored in tmp variable
    E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space (see implementation notes for details)
end
_make_figures("/tmp/tmpu5grybf1", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp6vcma1_b", "png", "Figure", -1, -1, 0, 0)
function EH = opEH(inp,S,traj)
  
  tmp = squeeze((1+1i)*ones(size(S)));
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp); % Adjoint NUFFT to image domain (see implementation notes)
  
  Sstar = conj(S(:,:,1,:)); %  Complex conjugate of sensitivity profiles (see Fig. 1)
  
  EH = bart('rss 8 ',tmp.*Sstar); % Images scaled by complex conjugate of sensitivity profiles and SOS combined
  
end
_make_figures("/tmp/tmp9bkgp6uq", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpxg4rilsu", "png", "Figure", -1, -1, 0, 0)
function out = opF(im,beta,r)
    
    ks = 1/sqrt(numel(im))*fftshift(fftn(ifftshift(im)));
    
    dim = size(ks);
    center = (dim + 1)/2;
    [x,y] = meshgrid(-(center(2)-1):(dim(2)-center(2)),-(center(1)-1):(dim(1)-center(1)));
    kRadius = sqrt(x.^2 + y.^2);
    f_k = 0.5 + 1/pi.*atan(beta.*((r-kRadius)/r)); 
    out = sqrt(numel(ks.*f_k))*fftshift(ifftn(ifftshift(ks.*f_k)));
end
_make_figures("/tmp/tmp85ujimwn", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmputw8ppsl", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
    
    if nargout ==3 && nargin ==7 
    % This means that ref image is passed. 
    
    refN = ref(:)'.*ref(:);
    ref_dif = I.*b - ref;
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))/refN);
    
    end 
    
end
_make_figures("/tmp/tmp47r0royt", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpt30o01f5", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a,refdif] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol,ref)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
     if nargout ==4 && nargin ==8 
    % This means that ref image is passed. 
    
        [im,deltas,refdif] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol,ref);
    
    else
    
        [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    
    end 
    
    im = opF(im.*I,100,60);
    
    
end
_make_figures("/tmp/tmpqjn8o2z7", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp58vtgovu", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmpfxb_ozh5", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp9m7jstgi", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmpffywpaxc", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpceyx17dh", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp2qy6_2fz", "png", "Figure", -1, -1, 0, 0)
S_select = 2
_make_figures("/tmp/tmpai7g0x0c", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpem98uwcu", "png", "Figure", -1, -1, 0, 0)
% This cell will be run automatically based upon your selection from the blue toggle above. 
% Perform NUFFT to interpolate data onto cartesian grid. 
im = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);
% Transform sensitivity maps to cartesian k-space using FFT
% -u denotes unitary transform
% 7 sets the bitmask level
im_ks = bart('fft -u 7', im);
% For details regarding BART's ECALIB, please see the implementation notes section.
if S_select == 1
    disp('Calculating S using ECALIB.');
    calib = bart('ecalib -r 20 -m1 -I',im_ks);
    disp('--> Done...')
elseif S_select == 2
    disp('Calculating S using CALDIR.');
    calib = bart('caldir 20',im_ks);
    disp('--> Done...'); 
end
_make_figures("/tmp/tmpqk3194sa", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpwefztv80", "png", "Figure", -1, -1, 0, 0)
% Please see HelperFunctions folder for subSample.m 
[outRD_x2, outTR_x2] = subSample(rawdata,trajectory,2,nSpokes);
[outRD_x3, outTR_x3] = subSample(rawdata,trajectory,3,nSpokes);
[outRD_x4, outTR_x4] = subSample(rawdata,trajectory,4,nSpokes);
_make_figures("/tmp/tmpdj8g5tys", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpghn_p3m6", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpp5zjagy8", "png", "Figure", -1, -1, 0, 0)
dcf_select = 1
_make_figures("/tmp/tmp9wc4_wut", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmppsceox5t", "png", "Figure", -1, -1, 0, 0)
% dcf_select variable is determined by the blue toggle buttons above.
% This cell will be run automatically upon your selection. 
if dcf_select == 1
   
    disp('Simple DCF estimation')
    dcf = abs(trajectory(1,:,:) + 1i*trajectory(2,:,:));
    dcf = dcf/max(dcf(:));
   disp('--> Done..');
   
elseif dcf_select==2
   
    disp('Calculating DCF using code written in C...')
    dcf = calcdcflut(trajectory,300); 
    dcf = reshape(dcf,[3 nFE nSpokes]);
    disp('--> Done..');
    
end
_make_figures("/tmp/tmph1zu4b30", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmplr2ra1bl", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
    tmp = S.*inp; % Multiply the intensity corrected image with coil sensitivities. This will produce one image per channel stored in tmp variable
    E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space (see implementation notes for details)
end
_make_figures("/tmp/tmpyi83mrxo", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpls2v9vz7", "png", "Figure", -1, -1, 0, 0)
function EH = opEH(inp,S,traj)
  
  tmp = squeeze((1+1i)*ones(size(S)));
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp); % Adjoint NUFFT to image domain (see implementation notes)
  
  Sstar = conj(S(:,:,1,:)); %  Complex conjugate of sensitivity profiles (see Fig. 1)
  
  EH = bart('rss 8 ',tmp.*Sstar); % Images scaled by complex conjugate of sensitivity profiles and SOS combined
  
end
_make_figures("/tmp/tmpk8rw94si", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpscw9e9wc", "png", "Figure", -1, -1, 0, 0)
function out = opF(im,beta,r)
    
    ks = 1/sqrt(numel(im))*fftshift(fftn(ifftshift(im)));
    
    dim = size(ks);
    center = (dim + 1)/2;
    [x,y] = meshgrid(-(center(2)-1):(dim(2)-center(2)),-(center(1)-1):(dim(1)-center(1)));
    kRadius = sqrt(x.^2 + y.^2);
    f_k = 0.5 + 1/pi.*atan(beta.*((r-kRadius)/r)); 
    out = sqrt(numel(ks.*f_k))*fftshift(ifftn(ifftshift(ks.*f_k)));
end
_make_figures("/tmp/tmpbk3oy26v", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpcyexj7hq", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
    
    if nargout ==3 && nargin ==7 
    % This means that ref image is passed. 
    
    refN = ref(:)'.*ref(:);
    ref_dif = I.*b - ref;
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))/refN);
    
    end 
    
end
_make_figures("/tmp/tmp56igl89u", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpjdhxvxnt", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a,refdif] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol,ref)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
     if nargout ==4 && nargin ==8 
    % This means that ref image is passed. 
    
        [im,deltas,refdif] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol,ref);
    
    else
    
        [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    
    end 
    
    im = opF(im.*I,100,60);
    
    
end
_make_figures("/tmp/tmpieq9ghtd", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpdt561wjy", "png", "Figure", -1, -1, 0, 0)
[im_ref,deltas_ref,init_ref] = main_sense(rawdata, calib, trajectory,I,dcf,30,10^(-12));
save ref_recon.mat im_ref deltas_ref init_ref
_make_figures("/tmp/tmp8f5ff7nn", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpidsnyqb7", "png", "Figure", -1, -1, 0, 0)
%[im_ref,deltas_ref,init_ref] = main_sense(rawdata, calib, trajectory,I,dcf,30,10^(-12));
%save ref_recon.mat im_ref deltas_ref init_ref
_make_figures("/tmp/tmpun5h2go5", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp0qj237w5", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref)
_make_figures("/tmp/tmpv4s64sid", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu Sep 19 16:53:13 2019 UTC <jovyan@41bebeae62a1>
