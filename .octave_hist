    else
    
        [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    
    end 
    
    im = opF(im.*I,100,60);
    
    
end
_make_figures("/tmp/tmpvnpjllpf", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpltd1qmtc", "png", "Figure", -1, -1, 0, 0)
%[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref);
_make_figures("/tmp/tmpraxjgamp", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpzr9l5d1b", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmpnp2vjpc7", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpyoydsk50", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmpx6ho5xif", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpmp5f02lg", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp46wsby7b", "png", "Figure", -1, -1, 0, 0)
S_select = 2
_make_figures("/tmp/tmpog6z079j", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmplm3ma7sx", "png", "Figure", -1, -1, 0, 0)
% This cell will be run automatically based upon your selection from the blue toggle above. 
% Perform NUFFT to interpolate data onto cartesian grid. 
im = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);
% Transform sensitivity maps to cartesian k-space using FFT
% -u denotes unitary transform
% 7 sets the bitmask level
im_ks = bart('fft -u 7', im);
% For details regarding BART's ECALIB, please see the implementation notes section.
if S_select == 1
    disp('Calculating S using ECALIB.');
    calib = bart('ecalib -r 20 -m1 -I',im_ks);
    disp('--> Done...')
elseif S_select == 2
    disp('Calculating S using CALDIR.');
    calib = bart('caldir 20',im_ks);
    disp('--> Done...'); 
end
_make_figures("/tmp/tmpsl25u0an", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmps9syilfb", "png", "Figure", -1, -1, 0, 0)
% Please see HelperFunctions folder for subSample.m 
[outRD_x2, outTR_x2] = subSample(rawdata,trajectory,2,nSpokes);
[outRD_x3, outTR_x3] = subSample(rawdata,trajectory,3,nSpokes);
[outRD_x4, outTR_x4] = subSample(rawdata,trajectory,4,nSpokes);
_make_figures("/tmp/tmpm9m2bs4n", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmprzeyqpa8", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp_a_31nx4", "png", "Figure", -1, -1, 0, 0)
dcf_select = 1
_make_figures("/tmp/tmpea4195_m", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp5r7v44n4", "png", "Figure", -1, -1, 0, 0)
% dcf_select variable is determined by the blue toggle buttons above.
% This cell will be run automatically upon your selection. 
if dcf_select == 1
   
    disp('Simple DCF estimation')
    dcf = abs(trajectory(1,:,:) + 1i*trajectory(2,:,:));
    dcf = dcf/max(dcf(:));
   disp('--> Done..');
   
elseif dcf_select==2
   
    disp('Calculating DCF using code written in C...')
    dcf = calcdcflut(trajectory,300); 
    dcf = reshape(dcf,[3 nFE nSpokes]);
    disp('--> Done..');
    
end
_make_figures("/tmp/tmp61rri85w", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmppw3h6pef", "png", "Figure", -1, -1, 0, 0)
% Set iteration to 30 for reference. 
% OPTION: RE-RUN to create reference output. ===================== 
%{ 
[im_ref,deltas_ref,init_ref] = main_sense(rawdata, calib, trajectory,I,dcf,30,10^(-12));
save ref_recon.mat im_ref deltas_ref init_ref
%}
% OPTION: LOAD pre-calculated output ===================== 
load ref_recon.mat
_make_figures("/tmp/tmpjlsh92uh", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpus7b42bc", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref);
_make_figures("/tmp/tmpgeu0538g", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp7gqsdtze", "png", "Figure", -1, -1, 0, 0)
refdif
_make_figures("/tmp/tmps4x2to00", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpwxu21jan", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
    
    if nargout ==3 && nargin ==8 
    % This means that ref image is passed. 
    
    refN = ref(:)'.*ref(:);
    ref_dif = I.*b - ref;
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))/refN);
    
    end 
    
end
_make_figures("/tmp/tmpxn7j8pyj", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp1_ey8n4u", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a,refdif] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol,ref)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
     if nargout ==4 && nargin ==8 
    % This means that ref image is passed. 
        disp('Reference image is passed.');
        [im,deltas,refdif] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol,ref);
    
    else
    
        [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    
    end 
    
    im = opF(im.*I,100,60);
    
    
end
_make_figures("/tmp/tmpmrxn4lve", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpdbvcfbxb", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref);
_make_figures("/tmp/tmpgsls123e", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp1hqbarhg", "png", "Figure", -1, -1, 0, 0)
refdif
_make_figures("/tmp/tmpwy68xlq8", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpdbwi_k6u", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
    
    if nargout ==3 && nargin ==8 
    % This means that ref image is passed. 
    
    refN = dot(ref,ref);
    ref_dif = I.*b - ref;
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))/refN);
    
    end 
    
end
_make_figures("/tmp/tmpuwu8ofav", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpzfbqks2r", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref);
_make_figures("/tmp/tmp7of3dvr0", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmprp5hwszf", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
    for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    end
    
    
    if nargout ==3 && nargin ==8 
    % This means that ref image is passed. 
    
    refN = dot(ref,ref);
    ref_dif = I.*b - ref;
    refdif(ii) = sqrt((dot(ref_dif,ref_dif))./refN);
    
    end 
    
end
_make_figures("/tmp/tmp2724pi2k", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpqv2ehcuo", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref);
_make_figures("/tmp/tmphq9_xs3g", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmplmd7kv_v", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    
     if nargout ==3 && nargin ==8 
    % This means that ref image is passed. 
    
    refN = dot(ref,ref);
    size(refN)
    ref_dif = I.*b - ref;
    size(ref_dif)
    refdif(ii) = sqrt((dot(ref_dif,ref_dif))./refN);
    
    end 
    
end
    
    
   
end
_make_figures("/tmp/tmpkjrbbhaq", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp92o68s7g", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref);
_make_figures("/tmp/tmpw5u2x9q4", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpxjctr0np", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    
     if nargout ==3 && nargin ==8 
    % This means that ref image is passed. 
    
    refN = ref(:)'*ref(:);
    size(refN)
    ref_dif = I.*b - ref;
    size(ref_dif)
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:)))./refN);
    
    end 
    
end
    
    
   
end
_make_figures("/tmp/tmp2up9et7h", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp21aa8z89", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    
     if nargout ==3 && nargin ==8 
    % This means that ref image is passed. 
    
    refN = ref(:)'*ref(:);
    size(refN)
    ref_dif = I.*b - ref;
    size(ref_dif)
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:)))./refN);
    
    end 
    
end
    
    
   
end
_make_figures("/tmp/tmpbi6r7z3p", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp0cznu09v", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    
for ii=1:maxstep
    disp(['Iteration -->' num2str(ii)]);
    delta = r(:)'*r(:)/(a(:)'*a(:));
    
    disp(delta);
    deltas(ii) = delta;
    E = opE(p,S,trajectory);
    q = opEH(E,S,trajectory);
    % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
    term = dot(r,r)/dot(p,q);
    b = b + term*p;
    rprev = r;
    r = r - term*q;
    term2 = dot(r,r)/dot(rprev,rprev);
    p = r + term2*p;
    
    if (delta <= tol)
        printf ("%d has been reached\n", tol);
        break;
    endif
    
    if nargout ==3 && nargin ==8 
    % This means that ref image is passed. 
    
    refN = ref(:)'*ref(:);
    size(refN)
    ref_dif = I.*b - ref;
    size(ref_dif)
    refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:)))./refN);
    
    end 
    
end
    
    
   
end
_make_figures("/tmp/tmp2uiwaj8y", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpytgc96wj", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
        p = a;
        r = a;
        b = zeros(300,300);
        deltas = zeros(maxstep,1);
        refdif = zeros(maxstep,1);
    for ii=1:maxstep
        disp(['Iteration -->' num2str(ii)]);
        delta = r(:)'*r(:)/(a(:)'*a(:));
        disp(delta);
        deltas(ii) = delta;
        E = opE(p,S,trajectory);
        q = opEH(E,S,trajectory);
        % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
        term = dot(r,r)/dot(p,q);
        b = b + term*p;
        rprev = r;
        r = r - term*q;
        term2 = dot(r,r)/dot(rprev,rprev);
        p = r + term2*p;
        if (delta <= tol)
            printf ("%d has been reached\n", tol);
            break;
        endif
        if nargout ==3 && nargin ==8 
        % This means that ref image is passed. 
        refN = ref(:)'*ref(:);
        size(refN)
        ref_dif = I.*b - ref;
        size(ref_dif)
        refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:)))./refN);
        end 
    end
    
    
   
end
_make_figures("/tmp/tmp3iracioe", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp_pn2vhmw", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
        p = a;
        r = a;
        b = zeros(300,300);
        deltas = zeros(maxstep,1);
        refdif = zeros(maxstep,1);
    for ii=1:maxstep
        disp(['Iteration -->' num2str(ii)]);
        delta = r(:)'*r(:)/(a(:)'*a(:));
        disp(delta);
        deltas(ii) = delta;
        E = opE(p,S,trajectory);
        q = opEH(E,S,trajectory);
        % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
        term = dot(r,r)/dot(p,q);
        b = b + term*p;
        rprev = r;
        r = r - term*q;
        term2 = dot(r,r)/dot(rprev,rprev);
        p = r + term2*p;
        if (delta <= tol)
            printf ("%d has been reached\n", tol);
            break;
        endif
        if nargout ==3 && nargin ==8 
        % This means that ref image is passed. 
        refN = ref(:)'*ref(:);
        size(refN)
        ref_dif = I.*b - ref;
        size(ref_dif)
        refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))./refN);
        end 
    end
    
    
   
end
_make_figures("/tmp/tmpczb9loi9", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp5q_2wlba", "png", "Figure", -1, -1, 0, 0)
[im,deltas,a,refdif] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),5,0.01,im_ref);
_make_figures("/tmp/tmpvln28cz6", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmph2rob4q2", "png", "Figure", -1, -1, 0, 0)
refdif
_make_figures("/tmp/tmpeyi8iqqd", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpxxpl1fy8", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    for ii=1:maxstep
        disp(['Iteration -->' num2str(ii)]);
        delta = r(:)'*r(:)/(a(:)'*a(:));
        disp(delta);
        deltas(ii) = delta;
        E = opE(p,S,trajectory);
        q = opEH(E,S,trajectory);
        % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
        term = dot(r,r)/dot(p,q);
        b = b + term*p;
        rprev = r;
        r = r - term*q;
        term2 = dot(r,r)/dot(rprev,rprev);
        p = r + term2*p;
        if (delta <= tol)
            printf ("%d has been reached\n", tol);
            break;
        endif
        if nargout ==3 && nargin ==8 
        % This means that ref image is passed. 
        refN = ref(:)'*ref(:);
        ref_dif = I.*b - ref;
        refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))./refN);
        end 
    end
    
    
   
end
_make_figures("/tmp/tmpmyk9p3t5", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp327h1i39", "png", "Figure", -1, -1, 0, 0)
% Less iterations w/o subsampling 
[im,deltas,init,refdif] = main_sense(rawdata,calib,trajectory,I,dcf,15,0.01,im_ref);
% Reconstruction fo sub-sampled data 
[im_x2,deltas_x2,init_x2,refdif_x2] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),15,0.01,im_ref);
[im_x3,deltas_x3,init_x3,refdif_x3] = main_sense(outRD_x3,calib,outTR_x3,I,dcf(:,:,1:3:end),15,0.01,im_ref);
[im_x4,deltas_x4,init_x4,refdif_x4] = main_sense(outRD_x4,calib,outTR_x4,I,dcf(:,:,1:4:end),15,0.01,im_ref);
_make_figures("/tmp/tmp3dcyuvqp", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpjg2_g72n", "png", "Figure", -1, -1, 0, 0)
% Less iterations w/o subsampling 
%[im,deltas,init,refdif] = main_sense(rawdata,calib,trajectory,I,dcf,15,0.01,im_ref);
% Reconstruction fo sub-sampled data 
%[im_x2,deltas_x2,init_x2,refdif_x2] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),15,0.01,im_ref);
%[im_x3,deltas_x3,init_x3,refdif_x3] = main_sense(outRD_x3,calib,outTR_x3,I,dcf(:,:,1:3:end),15,0.01,im_ref);
%[im_x4,deltas_x4,init_x4,refdif_x4] = main_sense(outRD_x4,calib,outTR_x4,I,dcf(:,:,1:4:end),15,0.01,im_ref);
_make_figures("/tmp/tmpwk9_8t2v", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp905p4st1", "png", "Figure", -1, -1, 0, 0)
save sub_recon.mat im deltas init refdif im_x2 deltas_x2 init_x2 refdif_x2 im_x3 deltas_x3 init_x3 refdif_x3 im_x4 deltas_x4 init_x4 refdif_x4
_make_figures("/tmp/tmpk8msngsy", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp8q5b74xp", "png", "Figure", -1, -1, 0, 0)
% OPTION: RE-RUN to create outputs for sub-sampled data. ===================== 
%{
% Less iterations w/o subsampling 
[im,deltas,init,refdif] = main_sense(rawdata,calib,trajectory,I,dcf,15,0.01,im_ref);
% Reconstruction fo sub-sampled data 
[im_x2,deltas_x2,init_x2,refdif_x2] = main_sense(outRD_x2,calib,outTR_x2,I,dcf(:,:,1:2:end),15,0.01,im_ref);
[im_x3,deltas_x3,init_x3,refdif_x3] = main_sense(outRD_x3,calib,outTR_x3,I,dcf(:,:,1:3:end),15,0.01,im_ref);
[im_x4,deltas_x4,init_x4,refdif_x4] = main_sense(outRD_x4,calib,outTR_x4,I,dcf(:,:,1:4:end),15,0.01,im_ref);
save sub_recon.mat im deltas init refdif im_x2 deltas_x2 init_x2 refdif_x2 im_x3 deltas_x3 init_x3 refdif_x3 im_x4 deltas_x4 init_x4 refdif_x4 
%}
% OPTION: LOAD pre-calculated outputs ===================== 
load sub_recon.mat
_make_figures("/tmp/tmpgsu2nla6", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpzr57z72_", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp08hzudfr", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas))
_make_figures("/tmp/tmpjzphl7d2", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpsq7ccaad", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas))
_make_figures("/tmp/tmpvypqvcv8", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpfoglvh5p", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpwfms811l", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x2))
_make_figures("/tmp/tmpqcab7zgp", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmptboxlhjz", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x2))
_make_figures("/tmp/tmp7wi0oym4", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp1vkiwnkz", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpnml_5y5q", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x3))
_make_figures("/tmp/tmpnwuy9buf", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpi2a8uxy6", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x3))
_make_figures("/tmp/tmptsfl9wg3", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmps3w8flq9", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpvqksuquu", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x4))
_make_figures("/tmp/tmpctsjfqa9", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmppx4l7aq2", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x4))
_make_figures("/tmp/tmpwpvk6sez", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpcu627dz8", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpgq1zti5f", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas))
_make_figures("/tmp/tmp7j49wgjr", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpqusameo_", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas))
_make_figures("/tmp/tmpa4z8yb92", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpakwy407l", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp1xqxfjc_", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x2))
_make_figures("/tmp/tmpfovoak4g", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpyer7cawh", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x2))
_make_figures("/tmp/tmp98c65oz4", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp202_nq2g", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpt3n624vc", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x3))
_make_figures("/tmp/tmpkv045ekm", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpbioop8us", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x3))
_make_figures("/tmp/tmp1odrt0pc", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpfsvm7tik", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp824vgcse", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x4))
_make_figures("/tmp/tmpk636_sxh", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpm_75wy30", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(deltas_x4))
_make_figures("/tmp/tmp9vl7y7_o", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpei50jbi5", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpgd9l5igb", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif))
_make_figures("/tmp/tmp1jz166a4", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpcdogdmo_", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif))
_make_figures("/tmp/tmpp03_nchf", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp6408ogzx", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpa8kgavvm", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif_x2))
_make_figures("/tmp/tmpvckgu_6v", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp2mp0i3x9", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif_x2))
_make_figures("/tmp/tmpp5rtkqsx", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpcs7z2l77", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmphjf97j9_", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif_x3))
_make_figures("/tmp/tmp8qgaa8ld", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp77i2y0n3", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif_x3))
_make_figures("/tmp/tmprbq1m8ib", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp6xxyd0h3", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpxh0omxe_", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif_x4))
_make_figures("/tmp/tmpr_19v2gg", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpjgy96809", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(refdif_x4))
_make_figures("/tmp/tmp493oxw5s", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpd8qxohxx", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpiextajb4", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(I))
_make_figures("/tmp/tmpi5gab9os", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp92xbtjkx", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(I))
_make_figures("/tmp/tmpymbwe0rq", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpzrs0d7rt", "png", "Figure", -1, -1, 0, 0)
<div class="alert alert-danger">
  <strong><span class="badge">RUN FIRST</span></strong> <b> Depends on <strong><span class="badge">2.1</span></strong> &  
    <strong><span class="badge">3.2 to 3.8</span></strong></b> 
</div>
_make_figures("/tmp/tmpao2575tn", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp3fr37s48", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpn3znablg", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(I))
_make_figures("/tmp/tmpi5ylqdxo", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmprncgq34y", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(I))
_make_figures("/tmp/tmp3zlvjehc", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpe8w0mbg6", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities (estimated in section 2.1) from 12 channels 
I = abs(bart('rss 8',calib.*calib));
I = 1./sqrt(I);
_make_figures("/tmp/tmpmhi3be89", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpixwc9090", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp1w86ywh9", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(I))
_make_figures("/tmp/tmpion71rbc", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmplb8eushb", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(I))
_make_figures("/tmp/tmp7zcl_tp2", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpl1sytg3d", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpuc8kwb_d", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(calib))
_make_figures("/tmp/tmpel873lc1", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpt9tn_pr4", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(calib))
_make_figures("/tmp/tmpaqnufbl5", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu Sep 19 19:10:23 2019 UTC <jovyan@41bebeae62a1>
PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
graphics_toolkit
more off; source ~/.octaverc; cd("/home/jovyan");PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
addpath("/srv/conda/envs/notebook/lib/python3.7/site-packages/octave_kernel")
graphics_toolkit('gnuplot')
set(0, 'defaultfigurevisible', 'off');
version
path(path, '/srv/conda/envs/notebook/lib/python3.7/site-packages/sos_matlab')
pkg load dataframe
_make_figures("/tmp/tmplo5kwcda", "png", "Figure", -1, -1, 0, 0)
disp('Executed automatically');
disp('Cell to load octave packages. To show, select the cell and click arrow up icon in the toolbar.');
pkg load image 
pkg load optim
_make_figures("/tmp/tmpgsbqm4_z", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp9xzb5jkp", "png", "Figure", -1, -1, 0, 0)
% Mex c files for gridding by Brian Hargreaves and Philip Beatty 
% http://mrsrl.stanford.edu/~brian/gridding/
disp('Executed automatically');
disp('Cell to MEX c functions for dcf. To show, select the cell and click arrow up icon in the toolbar.');
mex gridlut_mex.c
mex calcdcflut_mex.c
_make_figures("/tmp/tmpdfk6l1jh", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpdb59rm0r", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmplbmv09e4", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpg8qv4e3z", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmp217sf_4w", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpmxuy8ev7", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
    tmp = S.*inp; % Multiply the intensity corrected image with coil sensitivities. This will produce one image per channel stored in tmp variable
    E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space (see implementation notes for details)
end
_make_figures("/tmp/tmpdreytq5f", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp3k8nrkf9", "png", "Figure", -1, -1, 0, 0)
function EH = opEH(inp,S,traj)
  
  tmp = squeeze((1+1i)*ones(size(S)));
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp); % Adjoint NUFFT to image domain (see implementation notes)
  
  Sstar = conj(S(:,:,1,:)); %  Complex conjugate of sensitivity profiles (see Fig. 1)
  
  EH = bart('rss 8 ',tmp.*Sstar); % Images scaled by complex conjugate of sensitivity profiles and SOS combined
  
end
_make_figures("/tmp/tmpkqwgq0xl", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmprw74fs2x", "png", "Figure", -1, -1, 0, 0)
function out = opF(im,beta,r)
    
    ks = 1/sqrt(numel(im))*fftshift(fftn(ifftshift(im)));
    
    dim = size(ks);
    center = (dim + 1)/2;
    [x,y] = meshgrid(-(center(2)-1):(dim(2)-center(2)),-(center(1)-1):(dim(1)-center(1)));
    kRadius = sqrt(x.^2 + y.^2);
    f_k = 0.5 + 1/pi.*atan(beta.*((r-kRadius)/r)); 
    out = sqrt(numel(ks.*f_k))*fftshift(ifftn(ifftshift(ks.*f_k)));
end
_make_figures("/tmp/tmpczeilfvv", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpfx1v4icj", "png", "Figure", -1, -1, 0, 0)
function [b,deltas,refdif] = cg_solve(a,I,S,dcf,maxstep,trajectory,tol,ref)
    p = a;
    r = a;
    b = zeros(300,300);
    deltas = zeros(maxstep,1);
    refdif = zeros(maxstep,1);
    for ii=1:maxstep
        disp(['Iteration -->' num2str(ii)]);
        delta = r(:)'*r(:)/(a(:)'*a(:));
        disp(delta);
        deltas(ii) = delta;
        E = opE(p,S,trajectory);
        q = opEH(E,S,trajectory);
        % dot(r,r) is equivalent to r(:)'*r(:). Used dot for easy reading. 
        term = dot(r,r)/dot(p,q);
        b = b + term*p;
        rprev = r;
        r = r - term*q;
        term2 = dot(r,r)/dot(rprev,rprev);
        p = r + term2*p;
        if (delta <= tol)
            printf ("%d has been reached\n", tol);
            break;
        endif
        if nargout ==3 && nargin ==8 
        % This means that ref image is passed. 
        refN = ref(:)'*ref(:);
        ref_dif = I.*b - ref;
        refdif(ii) = sqrt((ref_dif(:)'*ref_dif(:))./refN);
        end 
    end
    
    
   
end
_make_figures("/tmp/tmp25zkd9la", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmps47_pd49", "png", "Figure", -1, -1, 0, 0)
function [im,deltas,a,refdif] = main_sense(rawdata, calib, trajectory,I,dcf,maxiter,tol,ref)
    dcf = repmat(dcf,[1,1,1,12]);
    
    a = I.*opEH(dcf.*rawdata,calib,trajectory);
    
     if nargout ==4 && nargin ==8 
    % This means that ref image is passed. 
        disp('Reference image is passed.');
        [im,deltas,refdif] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol,ref);
    
    else
    
        [im,deltas] = cg_solve(a,I,calib,dcf,maxiter,trajectory,tol);
    
    end 
    
    im = opF(im.*I,100,60);
    
    
end
_make_figures("/tmp/tmptk09x8lo", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpk0s9u0pm", "png", "Figure", -1, -1, 0, 0)
load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');
whos % Show variables in the current scope
_make_figures("/tmp/tmp80uiaarq", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp3c_r5vxj", "png", "Figure", -1, -1, 0, 0)
rawdata = permute(rawdata,[4,3,2,1]); 
trajectory = permute(trajectory,[3,2,1]);
[~,nFE,nSpokes,nCh] = size(rawdata);
whos
_make_figures("/tmp/tmpskho1321", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp6_g6gqhz", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpgqyde94p", "png", "Figure", -1, -1, 0, 0)
S_select = 2
_make_figures("/tmp/tmp6hzrgzgt", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp9mi4stin", "png", "Figure", -1, -1, 0, 0)
% This cell will be run automatically based upon your selection from the blue toggle above. 
% Perform NUFFT to interpolate data onto cartesian grid. 
im = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);
% Transform sensitivity maps to cartesian k-space using FFT
% -u denotes unitary transform
% 7 sets the bitmask level
im_ks = bart('fft -u 7', im);
% For details regarding BART's ECALIB, please see the implementation notes section.
if S_select == 1
    disp('Calculating S using ECALIB.');
    calib = bart('ecalib -r 20 -m1 -I',im_ks);
    disp('--> Done...')
elseif S_select == 2
    disp('Calculating S using CALDIR.');
    calib = bart('caldir 20',im_ks);
    disp('--> Done...'); 
end
_make_figures("/tmp/tmpz7i8s9js", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmpxjwcel3l", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp4aaal_5w", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(calib))
_make_figures("/tmp/tmpd0p3r736", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp6w2diosq", "png", "Figure", -1, -1, 0, 0)
display(sos_py_repr(calib))
_make_figures("/tmp/tmpfudfqaxh", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu Sep 19 19:15:41 2019 UTC <jovyan@41bebeae62a1>
PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
graphics_toolkit
more off; source ~/.octaverc; cd("/home/jovyan");PS1('PEXPECT_PROMPT>'); PS2('PEXPECT_PROMPT_')
addpath("/srv/conda/envs/notebook/lib/python3.7/site-packages/octave_kernel")
graphics_toolkit('gnuplot')
set(0, 'defaultfigurevisible', 'off');
version
path(path, '/srv/conda/envs/notebook/lib/python3.7/site-packages/sos_matlab')
pkg load dataframe
_make_figures("/tmp/tmpeyev3dyb", "png", "Figure", -1, -1, 0, 0)
disp('Executed automatically');
disp('Cell to load octave packages. To show, select the cell and click arrow up icon in the toolbar.');
pkg load image 
pkg load optim
_make_figures("/tmp/tmpb5d7kt6m", "png", "Figure", -1, -1, 0, 0)
who('sos*')
_make_figures("/tmp/tmp03u2y6d2", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu Sep 19 19:15:50 2019 UTC <jovyan@41bebeae62a1>
