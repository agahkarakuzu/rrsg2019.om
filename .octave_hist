imagesc(sumSqrC)
I = sumSqrC;
_make_figures("/tmp/tmp5kd16rwh", "png", "Figure", -1, -1, 0, 0)
% Adjoint NUFFT to interpolate data onto cartesian grid. 
% -d denotes dimension (x:y:z, which is 300X300X1)
% -a denotes adjoint transform
% -i denotes inverse transform
adj = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);
% Transform regridded image back to k-space 
% 7 is for bitmasking 
adjk = bart('fft -u 7', adj);
% Estimate coil sensitivities using the k-space center (radius of 20). 
%calib = bart('caldir 20',adjk);
calib = bart('ecalib -m1 -I',adjk);
_make_figures("/tmp/tmpdr2z1w81", "png", "Figure", -1, -1, 0, 0)
sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));
size(sumSqrC)
imagesc(sumSqrC)
I = sumSqrC;
_make_figures("/tmp/tmpthch_o2g", "png", "Figure", -1, -1, 0, 0)
% Adjoint NUFFT to interpolate data onto cartesian grid. 
% -d denotes dimension (x:y:z, which is 300X300X1)
% -a denotes adjoint transform
% -i denotes inverse transform
adj = bart('nufft -d300:300:1 -i -c -t',trajectory,rawdata);
% Transform regridded image back to k-space 
% 7 is for bitmasking 
adjk = bart('fft -u 7', adj);
% Estimate coil sensitivities using the k-space center (radius of 20). 
%calib = bart('caldir 20',adjk);
calib = bart('ecalib -m1 -I',adjk);
_make_figures("/tmp/tmpml1zckb1", "png", "Figure", -1, -1, 0, 0)
sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));
size(sumSqrC)
imagesc(sumSqrC)
I = sumSqrC;
_make_figures("/tmp/tmpd8351jnb", "png", "Figure", -1, -1, 0, 0)
% Adjoint NUFFT to interpolate data onto cartesian grid. 
% -d denotes dimension (x:y:z, which is 300X300X1)
% -a denotes adjoint transform
% -i denotes inverse transform
adj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);
% Transform regridded image back to k-space 
% 7 is for bitmasking 
adjk = bart('fft -u 7', adj);
% Estimate coil sensitivities using the k-space center (radius of 20). 
%calib = bart('caldir 20',adjk);
calib = bart('ecalib -m1 -I',adjk);
_make_figures("/tmp/tmprvc7t7f2", "png", "Figure", -1, -1, 0, 0)
sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));
size(sumSqrC)
imagesc(sumSqrC)
I = sumSqrC;
_make_figures("/tmp/tmp2zjf7d_t", "png", "Figure", -1, -1, 0, 0)
% Adjoint NUFFT to interpolate data onto cartesian grid. 
% -d denotes dimension (x:y:z, which is 300X300X1)
% -a denotes adjoint transform
% -i denotes inverse transform
adj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);
% Transform regridded image back to k-space 
% 7 is for bitmasking 
adjk = bart('fft -u 7', adj);
% Estimate coil sensitivities using the k-space center (radius of 20). 
%calib = bart('caldir 20',adjk);
calib = bart('ecalib -m1 -I -a',adjk);
_make_figures("/tmp/tmpgfv7hin9", "png", "Figure", -1, -1, 0, 0)
sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));
size(sumSqrC)
imagesc(sumSqrC)
I = sumSqrC;
_make_figures("/tmp/tmpgly7lio9", "png", "Figure", -1, -1, 0, 0)
sumSqrC = sum(abs(calib.*conj(calib)),4);
size(sumSqrC)
imagesc(sumSqrC)
I = sumSqrC;
_make_figures("/tmp/tmpnefoc9qg", "png", "Figure", -1, -1, 0, 0)
sumSqrC = sum(real(calib.*conj(calib)),4);
size(sumSqrC)
imagesc(sumSqrC)
I = sumSqrC;
_make_figures("/tmp/tmpxomvv54j", "png", "Figure", -1, -1, 0, 0)
figure();
for ii=1:12
subplot(3,4,ii);
imagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);
end
_make_figures("/tmp/tmpe9tp6zzu", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib.*conj(calib)));
_make_figures("/tmp/tmplew0sucg", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib.*conj(calib)));
imagesc(I)
_make_figures("/tmp/tmphe8tr11k", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib));
imagesc(I)
_make_figures("/tmp/tmp1g298562", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib.*conj(calib)));
imagesc(I)
_make_figures("/tmp/tmp7ql55u1w", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib));
imagesc(I)
_make_figures("/tmp/tmpudpr0kvr", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = 1./abs(bart('rss 8',calib));
imagesc(I); title('Intensity correction');
_make_figures("/tmp/tmpje5ykys5", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib));
imagesc(I); title('Intensity correction');
_make_figures("/tmp/tmpza_epqf6", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib));
imagesc(I);
_make_figures("/tmp/tmp6p7wtme8", "png", "Figure", -1, -1, 0, 0)
% Load octave packages 
pkg load image 
pkg load optim
_make_figures("/tmp/tmpec149x_m", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj)
% Here inp size is (300,300)
% S is the sensitivities from 12 channels (300,300,1,12)
% traj is the k-space coordinates
tmp = S.*inp;
tmp = permute(tmp,[3 1 2 4]); % BART's convention 
E = bart('nufft -t',traj,tmp);
end
_make_figures("/tmp/tmplzzdz8s2", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj,I)
% Here inp size is (300,300)
% S is the sensitivities from 12 channels (300,300,1,12)
% traj is the k-space coordinates
inp = inp.*I; % Intensity corr
tmp = S.*inp; % Multiply intensity corrected images with coil sensitivities
E = bart('nufft -t',traj,tmp); % Transform back to the non-uniform k-space
end
_make_figures("/tmp/tmpwugcecon", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -t -a',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares
end
_make_figures("/tmp/tmpnhrsd7a3", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -t -a',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmplruko717", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmphocfz5s3", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,calib,rawdata,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmp_qb6k_o0", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmpo0bbcrum", "png", "Figure", -1, -1, 0, 0)
imagesc(b.*I);
_make_figures("/tmp/tmpxtdp1a7c", "png", "Figure", -1, -1, 0, 0)
imagesc(b./I);
_make_figures("/tmp/tmpax8dgz04", "png", "Figure", -1, -1, 0, 0)
imagesc(b.*I);
_make_figures("/tmp/tmpx6arj0tn", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmpsv4q39py", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(lele(30:300,45:250)))
_make_figures("/tmp/tmpx2303oee", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -a',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmp0b_7b_ue", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmpqcuq7mws", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,calib,rawdata,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpk6sh9r_b", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpckw9_rmc", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmpv25xbtox", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmphctvky4d", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmp9jxs0gs9", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpkfhbugbk", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpjxadoxkw", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmpe5sbtgr5", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpsqv4jrmi", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmpkssjqlaq", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpp94rzv3z", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmpd4ke1nzu", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpqrs82ly2", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = abs(bart('rss 8',calib.*conj(calib)));
imagesc(I);
_make_figures("/tmp/tmpplw5w7t5", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj,I)
% Here inp size is (300,300)
% S is the sensitivities from 12 channels (300,300,1,12)
% traj is the k-space coordinates
inp = inp.*I; % Intensity corr
tmp = S.*inp; % Multiply intensity corrected images with coil sensitivities
E = bart('nufft -t',traj,tmp); % Transform back to the non-uniform k-space
end
_make_figures("/tmp/tmplchlpe2u", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i',traj,inp.*dcf(1,:,:));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpemxkgn28", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmps0vdrq4y", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmp1xu62qvh", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmpyk11ih0c", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpy5si_bfl", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpezd4kllc", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpu1k9z75e", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj,I)
% Here inp size is (300,300)
% S is the sensitivities from 12 channels (300,300,1,12)
% traj is the k-space coordinates
inp = inp.*I; % Intensity corr
tmp = S.*inp; % Multiply intensity corrected images with coil sensitivities
E = bart('nufft -t -s',traj,tmp); % Transform back to the non-uniform k-space
end
_make_figures("/tmp/tmp61i9fb9u", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i -t -s',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmphc61cs8v", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmpn746ndy7", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
_make_figures("/tmp/tmpcmjxq6ml", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj,I)
% Here inp size is (300,300)
% S is the sensitivities from 12 channels (300,300,1,12)
% traj is the k-space coordinates
inp = inp.*I; % Intensity corr
tmp = S.*inp; % Multiply intensity corrected images with coil sensitivities
E = bart('nufft -t',traj,tmp); % Transform back to the non-uniform k-space
end
_make_figures("/tmp/tmp1g_fhszu", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmp0pre38fm", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmpjrobnn0e", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpxra4c872", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmplr1oe8ad", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmpstq4p296", "png", "Figure", -1, -1, 0, 0)
imagesc(b.*I);
_make_figures("/tmp/tmp7_lwmg5x", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmps7g7u233", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(lele(30:300,45:250)))
_make_figures("/tmp/tmpkyqtstk2", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(lele)
_make_figures("/tmp/tmporyy9uoj", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(lele))
_make_figures("/tmp/tmpnmtcxo1h", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmph_r29fjv", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmp0zb85a35", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpzvwikr25", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmp8diqn8cs", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -a -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmp9s9rdyb7", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpyw_kbtmv", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmpc1918m27", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % NUFFT to the image domain
  tmp = bart('nufft -d300:300:1 -i -r',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  out = tmp2.*I;
end
_make_figures("/tmp/tmpi7ar50fh", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration ' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev))
p = r + term2*p;
end
end
_make_figures("/tmp/tmp1zvifxum", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpzdzmi47i", "png", "Figure", -1, -1, 0, 0)
function E = opE(inp,S,traj,I)
% Here inp size is (300,300)
% S is the sensitivities from 12 channels (300,300,1,12)
% traj is the k-space coordinates
% Normally, I is not a part of operation E, added here for convenience. 
inp = inp.*I; % Intensity corr
tmp = S.*inp; % Multiply intensity corrected images with coil sensitivities
E = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space
end
_make_figures("/tmp/tmp4v1f1am4", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration -->' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
if all(logical(thr(:)<usrthr))
    break;
end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = real(dot(r,r))/dot(p,q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = real(dot(r,r)/dot(rprev,rprev));
p = r + term2*p;
end
end
_make_figures("/tmp/tmp7gju34qw", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
_make_figures("/tmp/tmprh7_ghpl", "png", "Figure", -1, -1, 0, 0)
# Root sum of square of sensitivities from 12 channels 
I = real(bart('rss 8',calib.*conj(calib)));
imagesc(I);
_make_figures("/tmp/tmps2ju_gon", "png", "Figure", -1, -1, 0, 0)
% Adjoint NUFFT to interpolate data onto cartesian grid. 
% -d denotes dimension (x:y:z, which is 300X300X1)
% -a denotes adjoint transform
% -i denotes inverse transform
adj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);
% Transform regridded image back to k-space 
% 7 is for bitmasking 
adjk = bart('fft -u 8', adj);
% Estimate coil sensitivities using the k-space center (radius of 20). 
calib = bart('ecalib -m1 -I -a',adjk);
_make_figures("/tmp/tmpgnckhimb", "png", "Figure", -1, -1, 0, 0)
figure();
for ii=1:12
subplot(3,4,ii);
imagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);
end
_make_figures("/tmp/tmpn55wpqvn", "png", "Figure", -1, -1, 0, 0)
% Adjoint NUFFT to interpolate data onto cartesian grid. 
% -d denotes dimension (x:y:z, which is 300X300X1)
% -a denotes adjoint transform
% -i denotes inverse transform
adj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);
% Transform regridded image back to k-space 
% 7 is for bitmasking 
adjk = bart('fft -u 3', adj);
% Estimate coil sensitivities using the k-space center (radius of 20). 
calib = bart('ecalib -m1 -I',adjk);
_make_figures("/tmp/tmpju4sqfke", "png", "Figure", -1, -1, 0, 0)
figure();
for ii=1:12
subplot(3,4,ii);
imagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);
end
_make_figures("/tmp/tmp0_nbpsz1", "png", "Figure", -1, -1, 0, 0)
% Adjoint NUFFT to interpolate data onto cartesian grid. 
% -d denotes dimension (x:y:z, which is 300X300X1)
% -a denotes adjoint transform
% -i denotes inverse transform
adj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);
% Transform regridded image back to k-space 
% 7 is for bitmasking 
adjk = bart('fft -u 7', adj);
% Estimate coil sensitivities using the k-space center (radius of 20). 
calib = bart('ecalib -m1 -I',adjk);
_make_figures("/tmp/tmpod6x8uhc", "png", "Figure", -1, -1, 0, 0)
figure();
for ii=1:12
subplot(3,4,ii);
imagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);
end
_make_figures("/tmp/tmphiuvmb1n", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmpyeg6ttek", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(lele))
_make_figures("/tmp/tmpl0drsrve", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpfewafsa5", "png", "Figure", -1, -1, 0, 0)
function out = opEH(dcf,inp,S,traj,I)
% dcf is density compensation factor , see 3.2
% input samples respecting the size of the rawdata (1,512,96,12) 
% S is the coil sensitivities 
% traj is the k-space coordinates 
  % Inverse NUFFT to the image domain using Toeplitz embedding
  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));
  
  % Get complex conjugate of sensitivity profiles
  Sstar = conj(S(:,:,1,:));
  
  % Root sum of square of the images, scaled by complex conjugate of the sensitivity maps.
  tmp2 = bart('rss 8 ',tmp.*Sstar);
  
  % Intensity correction
  out = tmp2.*I;
end
_make_figures("/tmp/tmpijgsckrl", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmpfzciuwxx", "png", "Figure", -1, -1, 0, 0)
imagesc(b.*I);
_make_figures("/tmp/tmp7hq9cf0n", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmpesnlcehm", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(lele))
_make_figures("/tmp/tmpsq3luex7", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((25-abs(-150:149))/25));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmpzpwn22_9", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(lele))
_make_figures("/tmp/tmp3zwpgkvr", "png", "Figure", -1, -1, 0, 0)
imshow(abs(lele),[])
_make_figures("/tmp/tmp95o86gee", "png", "Figure", -1, -1, 0, 0)
imshow(imrotate(abs(lele),90),[])
_make_figures("/tmp/tmpnbjvl_cy", "png", "Figure", -1, -1, 0, 0)
imshow(imrotate(abs(lele),180),[])
_make_figures("/tmp/tmpe0e7t52j", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmpflprx8sv", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmpdg4u480c", "png", "Figure", -1, -1, 0, 0)
imshow(imrotate(abs(lele),180),[])
_make_figures("/tmp/tmpvtg4l575", "png", "Figure", -1, -1, 0, 0)
imshow(abs(lele),[])
_make_figures("/tmp/tmpf9rg5fg6", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration -->' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
%if all(logical(thr(:)<usrthr))
 %   break;
%end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
% term = real(dot(r,r))/dot(p,q);
term = abs(r*ctranspose(r)/ctranspose(p)*q);
b = b + term*p;
rprev = r;
r = r - term*q;
%term2 = real(dot(r,r)/dot(rprev,rprev));
term2 = abs(r*ctranspose(r)/ctranspose(rprev)*rprev));
p = r + term2*p;
end
end
_make_figures("/tmp/tmp3aqjyl3u", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration -->' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
%if all(logical(thr(:)<usrthr))
 %   break;
%end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
% term = real(dot(r,r))/dot(p,q);
term = abs(r*ctranspose(r)/ctranspose(p)*q);
b = b + term*p;
rprev = r;
r = r - term*q;
%term2 = real(dot(r,r)/dot(rprev,rprev));
term2 = abs(r*ctranspose(r)/ctranspose(rprev)*rprev);
p = r + term2*p;
end
end
_make_figures("/tmp/tmpimbmlofx", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmpg6ovbwiv", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmp03jdq9qx", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration -->' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
%if all(logical(thr(:)<usrthr))
 %   break;
%end
E = opE(I.*p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
% term = real(dot(r,r))/dot(p,q);
term = real(r*ctranspose(r)/ctranspose(p)*q);
b = b + term*p;
rprev = r;
r = r - term*q;
%term2 = real(dot(r,r)/dot(rprev,rprev));
term2 = real(r*ctranspose(r)/ctranspose(rprev)*rprev);
p = r + term2*p;
end
end
_make_figures("/tmp/tmpu2m3yzeg", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmp3mmy534f", "png", "Figure", -1, -1, 0, 0)
function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)
p = a;
r = a;
b = zeros(300,300);
for ii=1:maxstep
disp(['Iteration -->' num2str(ii)]);
thr = norm(r).^2./norm(b).^2;
disp(thr);
%if all(logical(thr(:)<usrthr))
 %   break;
%end
E = opE(p,S,trajectory);
q = opEH(dcf,E,S,trajectory,I);
term = abs(dot(r,r))/dot(p,q);
% The following fails 
% term = real(r*ctranspose(r)/ctranspose(p)*q);
b = b + term*p;
rprev = r;
r = r - term*q;
term2 = abs(dot(r,r)/dot(rprev,rprev));
% The following fails 
% term2 = real(r*ctranspose(r)/ctranspose(rprev)*rprev);
p = r + term2*p;
end
end
_make_figures("/tmp/tmpo0sz0s3k", "png", "Figure", -1, -1, 0, 0)
a = opEH(dcf,rawdata,calib,trajectory,I);
b = cg_solve(a,I,calib,dcf,10,trajectory,0.001);
_make_figures("/tmp/tmp1mphigyt", "png", "Figure", -1, -1, 0, 0)
imagesc(abs(b(30:300,40:250)))
_make_figures("/tmp/tmp95yx1egf", "png", "Figure", -1, -1, 0, 0)
imagesc(b.*I);
_make_figures("/tmp/tmp1i6yi_ps", "png", "Figure", -1, -1, 0, 0)
k_b = fftshift(fft2(b));
k = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));
yy = repmat(k,[300 1]);
lele= ifft2(ifftshift(k_b.*yy'));
_make_figures("/tmp/tmpsiax5ln6", "png", "Figure", -1, -1, 0, 0)
imshow(abs(lele),[])
_make_figures("/tmp/tmp6r2v7j3n", "png", "Figure", -1, -1, 0, 0)
# Octave 4.2.2, Thu May 02 04:09:55 2019 UTC <agah@05cb39751d53>
