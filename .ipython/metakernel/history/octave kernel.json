["% Load octave packages \npkg load image \npkg load optim", "% Mex c files for gridding by Brian Hargreaves and Philip Beatty \n% http://mrsrl.stanford.edu/~brian/gridding/\n\nmex gridlut_mex.c\nmex calcdcflut_mex.c", "load('/tmp/rrsg_challenge/brain_radial_96proj_12ch.mat');\nwhos % Show variables in the current scope", "rawdata = permute(rawdata,[4,3,2,1]); \ntrajectory = permute(trajectory,[3,2,1]);\n[~,nFE,nSpokes,nCh] = size(rawdata);\nwhos", "for ii=1:12\ncc = squeeze((rawdata(1,:,:,ii)));\n% Brighten convention is not 1/1 with matlab.  \nsubplot(2,6,ii);\nimshow(log(1+abs(cc)),[-0 0.0001]); brighten(0.4); title(['Ch ' num2str(ii)]);\nend", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\ncalib = bart('caldir 20',adjk);", "dcf = calcdcflut(trajectory,300); \ndcf = reshape(dcf,[3 nFE nSpokes]);", "# Root sum of square of sensitivities from 12 channels \n\nI = (1./bart('rss 8',calib));", "function E = opE(inp,S,traj)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\n\ntmp = S.*inp;\ntmp = permute(tmp,[3 1 2 4]); % BART's convention \nE = bart('nufft',traj,tmp);\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*dcf(1,:,:));\n  Sstar = conj(S(:,:,1,:));\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function E = opE(inp,S,traj)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\n\ntmp = S.*inp;\ntmp = permute(tmp,[3 1 2 4]); % BART's convention \nE = bart('nufft',traj,tmp);\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*dcf(1,:,:));\n  Sstar = conj(S(:,:,1,:));\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function a = get_a(dcf,S,rawdata,traj,I)\n\n    tmp = bart('nufft -d300:300:1 -i',traj,rawdata.*dcf(1,:,:));\n    Sstar = conj(S(:,:,1,:));\n    tmp2 = bart('rss 8 ',tmp.*Sstar);\n    a = tmp2.*I;\n\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = (conj(r)*r)/(conj(a)*a);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\n\n\nend", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,20,trajectory,0.01);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b*I);", "imagesc(b.*I);", "help imfilter", "help fspecial", "h = hann(b);", "% Load octave packages \npkg load image \npkg load optim\npkg load signal", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((20-k_b)/20);\n\nlele= ifft2(ifftshift(k));", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((20-k_b)/20));\n\nlele= ifft2(ifftshift(k));", "imagesc(abs(lele))", "imagesc(lele)", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((20-abs(-150:150))/20));\n\nlele= ifft2(ifftshift(k_b.*k));", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((20-abs(-149:150))/20));\nrepmat(k,[1 300]);\n\nlele= ifft2(ifftshift(k_b.*k));", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((20-abs(-149:150))/20));\nyy = repmat(k,[1 300]);\n\nlele= ifft2(ifftshift(k_b.*yy));", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((20-abs(-149:150))/20));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy));", "imagesc(abs(lele))", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((70-abs(-149:150))/70));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy));", "imagesc(abs(lele))", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((1-abs(-149:150))/1));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy));", "imagesc(abs(lele))", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((10-abs(-149:150))/10));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy));", "imagesc(abs(lele))", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy));", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy));", "imagesc(abs(lele))", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele))", "imagesc(b./I);", "imagesc(abs(lele(30:300,30:300)))", "imagesc(abs(lele(30:300,40:250)))", "imagesc(abs(lele(30:300,45:250)))", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(res).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\n\n\nend", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\n\n\nend", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,100,trajectory,0.001);", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*sqrt(dcf(1,:,:));\n  Sstar = conj(S(:,:,1,:));\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function a = get_a(dcf,S,rawdata,traj,I)\n\n    tmp = bart('nufft -d300:300:1 -i',traj,rawdata.*sqrt(dcf(1,:,:)));\n    Sstar = conj(S(:,:,1,:));\n    tmp2 = bart('rss 8 ',tmp.*Sstar);\n    a = tmp2.*I;\n\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\n\n\nend", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,100,trajectory,0.001);", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b./I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\n\n\nend", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b./I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -a',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\ncalib = bart('caldir 20',adjk);", "# Root sum of square of sensitivities from 12 channels \n\nI = (1./bart('rss 8',calib));", "function E = opE(inp,S,traj)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\n\ntmp = S.*inp;\ntmp = permute(tmp,[3 1 2 4]); % BART's convention \nE = bart('nufft',traj,tmp);\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*sqrt(dcf(1,:,:));\n  Sstar = conj(S(:,:,1,:));\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*sqrt(dcf(1,:,:));\n  Sstar = conj(S(:,:,1,:));\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*sqrt(dcf(1,:,:)));\n  Sstar = conj(S(:,:,1,:));\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function a = get_a(dcf,S,rawdata,traj,I)\n\n    tmp = bart('nufft -d300:300:1 -i',traj,rawdata.*sqrt(dcf(1,:,:)));\n    Sstar = conj(S(:,:,1,:));\n    tmp2 = bart('rss 8 ',tmp.*Sstar);\n    a = tmp2.*I;\n\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\n\n\nend", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(abs(b(30:300,40:250)))", "imagesc(b./I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "figure();\nfor ii=1:12\nsubplot(3,4,ii);\nimagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);\nend", "# Root sum of square of sensitivities from 12 channels \n\nI = (1./bart('rss 8',calib));\nimagesc(I)", "# Root sum of square of sensitivities from 12 channels \n\nI = (1./bart('rss 8',calib));", "function E = opE(inp,S,traj)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\n\ntmp = S.*inp;\ntmp = permute(tmp,[3 1 2 4]); % BART's convention \nE = bart('nufft',traj,tmp);\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*sqrt(dcf(1,:,:)));\n  Sstar = conj(S(:,:,1,:));\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function a = get_a(dcf,S,rawdata,traj,I)\n\n    tmp = bart('nufft -d300:300:1 -i',traj,rawdata.*sqrt(dcf(1,:,:)));\n    Sstar = conj(S(:,:,1,:));\n    tmp2 = bart('rss 8 ',tmp.*Sstar);\n    a = tmp2.*I;\n\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\n\n\nend", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,30,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b./I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\ncalib = bart('caldir 20',adjk);\n\nsumSqrC = sqrt(sum(abs(calib * conj(calib)), 0));", "sumSqrC = sqrt(sum(abs(calib .* conj(calib)), 0));", "sumSqrC = sqrt(sum(abs(calib .* conj(calib))));", "sumSqrC = sqrt(sum(abs(calib .* conj(calib))));\nsize(sumSqrC)", "sumSqrC = sqrt(sum(abs(calib .* conj(calib)),4));\nsize(sumSqrC)", "sumSqrC = sqrt(sum(abs(calib .* conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\n%calib = bart('caldir 20',adjk);\n\ncalib = bart('ecalib -m1 -I',adjk);", "figure();\nfor ii=1:12\nsubplot(3,4,ii);\nimagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);\nend", "# Root sum of square of sensitivities from 12 channels \n\nI = (bart('rss 8',calib));", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b./I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "sumSqrC = sqrt(sum(abs(calib' * conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)", "sumSqrC = sqrt(sum(abs(calib' * conj(calib)'),4));\nsize(sumSqrC)\nimagesc(sumSqrC)", "sumSqrC = sqrt(sum(abs(calib * conj(calib)'),4));\nsize(sumSqrC)\nimagesc(sumSqrC)", "sumSqrC = sqrt(sum(abs(calib .* conj(calib)'),4));\nsize(sumSqrC)\nimagesc(sumSqrC)", "sumSqrC = sqrt(sum(abs(calib .* conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)", "sumSqrC = sqrt(sum(abs(calib .* conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "a = get_a(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b./I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "sumSqrC = sqrt(sum(abs(calib .* conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "sumSqrC = sqrt(sum(abs(calib * conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "sumSqrC = sqrt(sum(abs(calib*conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -a -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\n%calib = bart('caldir 20',adjk);\n\ncalib = bart('ecalib -m1 -I',adjk);", "sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -c -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\n%calib = bart('caldir 20',adjk);\n\ncalib = bart('ecalib -m1 -I',adjk);", "sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\n%calib = bart('caldir 20',adjk);\n\ncalib = bart('ecalib -m1 -I',adjk);", "sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\n%calib = bart('caldir 20',adjk);\n\ncalib = bart('ecalib -m1 -I -a',adjk);", "sumSqrC = sqrt(sum(abs(calib.*conj(calib)),4));\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "sumSqrC = sum(abs(calib.*conj(calib)),4);\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "sumSqrC = sum(real(calib.*conj(calib)),4);\nsize(sumSqrC)\nimagesc(sumSqrC)\nI = sumSqrC;", "figure();\nfor ii=1:12\nsubplot(3,4,ii);\nimagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);\nend", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib.*conj(calib)));", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib.*conj(calib)));\nimagesc(I)", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib));\nimagesc(I)", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib.*conj(calib)));\nimagesc(I)", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib));\nimagesc(I)", "# Root sum of square of sensitivities from 12 channels \n\nI = 1./abs(bart('rss 8',calib));\nimagesc(I); title('Intensity correction');", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib));\nimagesc(I); title('Intensity correction');", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib));\nimagesc(I);", "% Load octave packages \npkg load image \npkg load optim", "function E = opE(inp,S,traj)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\n\ntmp = S.*inp;\ntmp = permute(tmp,[3 1 2 4]); % BART's convention \nE = bart('nufft -t',traj,tmp);\nend", "function E = opE(inp,S,traj,I)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\ninp = inp.*I; % Intensity corr\ntmp = S.*inp; % Multiply intensity corrected images with coil sensitivities\nE = bart('nufft -t',traj,tmp); % Transform back to the non-uniform k-space\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -t -a',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\n%EH = bart('rss 8',Sstar.*tmp); % Root sum of squares\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -t -a',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b.*I);", "imagesc(b./I);", "imagesc(b.*I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -a',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,calib,rawdata,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -a -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "# Root sum of square of sensitivities from 12 channels \n\nI = abs(bart('rss 8',calib.*conj(calib)));\nimagesc(I);", "function E = opE(inp,S,traj,I)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\ninp = inp.*I; % Intensity corr\ntmp = S.*inp; % Multiply intensity corrected images with coil sensitivities\nE = bart('nufft -t',traj,tmp); % Transform back to the non-uniform k-space\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i',traj,inp.*dcf(1,:,:));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function E = opE(inp,S,traj,I)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\ninp = inp.*I; % Intensity corr\ntmp = S.*inp; % Multiply intensity corrected images with coil sensitivities\nE = bart('nufft -t -s',traj,tmp); % Transform back to the non-uniform k-space\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i -t -s',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "function E = opE(inp,S,traj,I)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\ninp = inp.*I; % Intensity corr\ntmp = S.*inp; % Multiply intensity corrected images with coil sensitivities\nE = bart('nufft -t',traj,tmp); % Transform back to the non-uniform k-space\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(abs(b(30:300,40:250)))", "imagesc(b.*I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((30-abs(-149:150))/30));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele(30:300,45:250)))", "imagesc(abs(lele)", "imagesc(abs(lele))", "imagesc(abs(lele))", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -a -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % NUFFT to the image domain\n  tmp = bart('nufft -d300:300:1 -i -r',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  out = tmp2.*I;\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration ' num2str(ii)]);\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev))\np = r + term2*p;\n\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "function E = opE(inp,S,traj,I)\n% Here inp size is (300,300)\n% S is the sensitivities from 12 channels (300,300,1,12)\n% traj is the k-space coordinates\n% Normally, I is not a part of operation E, added here for convenience. \n\ninp = inp.*I; % Intensity corr\ntmp = S.*inp; % Multiply intensity corrected images with coil sensitivities\nE = bart('nufft',traj,tmp); % Transform back to the non-uniform k-space\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration -->' num2str(ii)]);\n\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\nif all(logical(thr(:)<usrthr))\n    break;\nend\n\nE = opE(I.*p,S,trajectory);\n\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = real(dot(r,r))/dot(p,q);\n\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = real(dot(r,r)/dot(rprev,rprev));\n\np = r + term2*p;\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "# Root sum of square of sensitivities from 12 channels \n\nI = real(bart('rss 8',calib.*conj(calib)));\nimagesc(I);", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 8', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\ncalib = bart('ecalib -m1 -I -a',adjk);", "figure();\nfor ii=1:12\nsubplot(3,4,ii);\nimagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);\nend", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 3', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\ncalib = bart('ecalib -m1 -I',adjk);", "figure();\nfor ii=1:12\nsubplot(3,4,ii);\nimagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);\nend", "% Adjoint NUFFT to interpolate data onto cartesian grid. \n% -d denotes dimension (x:y:z, which is 300X300X1)\n% -a denotes adjoint transform\n% -i denotes inverse transform\n\nadj = bart('nufft -d300:300:1 -i -l -t',trajectory,rawdata);\n\n% Transform regridded image back to k-space \n% 7 is for bitmasking \n\nadjk = bart('fft -u 7', adj);\n\n% Estimate coil sensitivities using the k-space center (radius of 20). \n\ncalib = bart('ecalib -m1 -I',adjk);", "figure();\nfor ii=1:12\nsubplot(3,4,ii);\nimagesc(log(1+abs(calib(:,:,1,ii)))); axis off; title(['Ch ' num2str(ii)]);\nend", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele))", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "function out = opEH(dcf,inp,S,traj,I)\n% dcf is density compensation factor , see 3.2\n% input samples respecting the size of the rawdata (1,512,96,12) \n% S is the coil sensitivities \n% traj is the k-space coordinates \n\n  % Inverse NUFFT to the image domain using Toeplitz embedding\n  tmp = bart('nufft -d300:300:1 -i -t',traj,inp.*sqrt(dcf(1,:,:)));\n  \n  % Get complex conjugate of sensitivity profiles\n  Sstar = conj(S(:,:,1,:));\n  \n  % Root sum of square of the images, scaled by complex conjugate of the sensitivity maps.\n  tmp2 = bart('rss 8 ',tmp.*Sstar);\n  \n  % Intensity correction\n  out = tmp2.*I;\n\nend", "imagesc(abs(b(30:300,40:250)))", "imagesc(b.*I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele))", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((25-abs(-150:149))/25));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imagesc(abs(lele))", "imshow(abs(lele),[])", "imshow(imrotate(abs(lele),90),[])", "imshow(imrotate(abs(lele),180),[])", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imshow(imrotate(abs(lele),180),[])", "imshow(abs(lele),[])", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration -->' num2str(ii)]);\n\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\n%if all(logical(thr(:)<usrthr))\n %   break;\n%end\n\nE = opE(I.*p,S,trajectory);\n\nq = opEH(dcf,E,S,trajectory,I);\n\n% term = real(dot(r,r))/dot(p,q);\nterm = abs(r*ctranspose(r)/ctranspose(p)*q);\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\n%term2 = real(dot(r,r)/dot(rprev,rprev));\nterm2 = abs(r*ctranspose(r)/ctranspose(rprev)*rprev));\n\np = r + term2*p;\n\nend\n\nend", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration -->' num2str(ii)]);\n\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\n%if all(logical(thr(:)<usrthr))\n %   break;\n%end\n\nE = opE(I.*p,S,trajectory);\n\nq = opEH(dcf,E,S,trajectory,I);\n\n% term = real(dot(r,r))/dot(p,q);\nterm = abs(r*ctranspose(r)/ctranspose(p)*q);\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\n%term2 = real(dot(r,r)/dot(rprev,rprev));\nterm2 = abs(r*ctranspose(r)/ctranspose(rprev)*rprev);\n\np = r + term2*p;\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration -->' num2str(ii)]);\n\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\n%if all(logical(thr(:)<usrthr))\n %   break;\n%end\n\nE = opE(I.*p,S,trajectory);\n\nq = opEH(dcf,E,S,trajectory,I);\n\n% term = real(dot(r,r))/dot(p,q);\nterm = real(r*ctranspose(r)/ctranspose(p)*q);\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\n%term2 = real(dot(r,r)/dot(rprev,rprev));\nterm2 = real(r*ctranspose(r)/ctranspose(rprev)*rprev);\n\np = r + term2*p;\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "function b = cg_solve(a,I,S,dcf,maxstep,trajectory,usrthr)\np = a;\nr = a;\nb = zeros(300,300);\n\nfor ii=1:maxstep\n\ndisp(['Iteration -->' num2str(ii)]);\n\nthr = norm(r).^2./norm(b).^2;\ndisp(thr);\n\n%if all(logical(thr(:)<usrthr))\n %   break;\n%end\n\nE = opE(p,S,trajectory);\n\nq = opEH(dcf,E,S,trajectory,I);\n\nterm = abs(dot(r,r))/dot(p,q);\n% The following fails \n% term = real(r*ctranspose(r)/ctranspose(p)*q);\nb = b + term*p;\n\nrprev = r;\nr = r - term*q;\n\nterm2 = abs(dot(r,r)/dot(rprev,rprev));\n\n% The following fails \n% term2 = real(r*ctranspose(r)/ctranspose(rprev)*rprev);\n\np = r + term2*p;\n\nend\n\nend", "a = opEH(dcf,rawdata,calib,trajectory,I);\nb = cg_solve(a,I,calib,dcf,10,trajectory,0.001);", "imagesc(abs(b(30:300,40:250)))", "imagesc(b.*I);", "k_b = fftshift(fft2(b));\n\nk = 0.5 + 1/pi.*atan(100.*((40-abs(-150:149))/40));\nyy = repmat(k,[300 1]);\n\nlele= ifft2(ifftshift(k_b.*yy'));", "imshow(abs(lele),[])"]